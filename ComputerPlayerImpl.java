package student;import model.*;import javax.management.relation.RoleUnresolved;import java.util.*;public class ComputerPlayerImpl implements Player{    /*    will likely  need to access RailroadBarons implementation and the map    autoplays the game during its turn    computer player will make decisions about what move to make based on the    cards currently in hand and the number of train pieces remaining.    Dumb player will clam the first unclaimed route that it is capable    of claiming,    Smarter players will be more strategic     */    private int score;    private int numTrainPieces;    private ArrayList<Route> claimedRoutes;    private Baron baron;    private Pair pair;    private HashMap<Card, Integer> hand;    private ArrayList<PlayerObserver> observers;    private boolean hasclaimed;    private RailroadBarons game;    private ArrayList<Route> possibleRoutes;    private Graph graph;    /**     * constructor for the computer player using railroadbaronlonely implementation     * @param baron the color that this computer player has     * @param game the current game     */    public ComputerPlayerImpl(Baron baron, RailroadBaronLonelyImpl game){        this.baron = baron;        this.score = 0;        this.numTrainPieces = 45;        this.claimedRoutes = new ArrayList<>();        this.hand = new HashMap<>();        this.observers = new ArrayList<>();        hasclaimed = false;        this.game = game;        this.possibleRoutes = new ArrayList<>();        graph = new Graph(game);    }    /**     * This is called at the start of every game to reset the player to its     * initial state:     * <ul>     *     <li>Number of train pieces reset to the starting number of 45.</li>     *     <li>All remaining {@link Card cards} cleared from hand.</li>     *     <li>Score reset to 0.</li>     *     <li>Claimed {@link Route routes} cleared.</li>     *     <li>Sets the most recently dealt {@link Pair} of cards to two     *     {@link Card#NONE} values.</li>     * </ul>     *     * @param dealt The hand of {@link Card cards} dealt to the player at the     *              start of the game. By default this will be 4 cards.     */    @Override    public void reset(Card... dealt) {        ArrayList<Card> dealtCards  = new ArrayList<>();        dealtCards.addAll(Arrays.asList(dealt));        this.numTrainPieces = 45;        for (Card card: dealtCards){            if (hand.containsKey(card)){                int a = hand.get(card);                a = a + 1;                hand.replace(card, a);            }            else{                hand.put(card, 1);            }        }        this.score = 0;        this.claimedRoutes = new ArrayList<>();        this.pair = new PairImpl(Card.NONE, Card.NONE);        for (PlayerObserver observer: observers){            observer.playerChanged(this);        }        this.possibleRoutes = new ArrayList<>();    }    /**     * Adds an {@linkplain PlayerObserver observer} that will be notified when     * the player changes in some way.     *     * @param observer The new {@link PlayerObserver}.     */    @Override    public void addPlayerObserver(PlayerObserver observer) {        observers.add(observer);    }    /**     * Removes an {@linkplain PlayerObserver observer} so that it is no longer     * notified when the player changes in some way.     *     * @param observer The {@link PlayerObserver} to remove.     */    @Override    public void removePlayerObserver(PlayerObserver observer) {        observers.remove(observer);    }    /**     * The {@linkplain Baron baron} as which this player is playing the game.     *     * @return The {@link Baron} as which this player is playing.     */    @Override    public Baron getBaron() {        return this.baron;    }    /**     * Used to start the player's next turn. A {@linkplain Pair pair of cards}     * is dealt to the player, and the player is once again able to claim a     * {@linkplain Route route} on the {@linkplain RailroadMap map}.     *     * @param dealt a {@linkplain Pair pair of cards} to the player. Note that     * one or both of these cards may have a value of {@link Card#NONE}.     */    @Override    public void startTurn(Pair dealt) {        this.pair = dealt;        hasclaimed = false;        if (hand.containsKey(pair.getFirstCard())){            for (Card card: Card.values()){                if (pair.getFirstCard().equals(card)) {                    int a = hand.get(pair.getFirstCard());                    a = a +1;                    hand.replace(card,a-1, a+1);                }            }        }        else {            hand.put(pair.getFirstCard(), 1);        }        if (hand.containsKey(pair.getSecondCard())){            for (Card card: Card.values()){                if (pair.getSecondCard().equals(card)) {                    int a = hand.get(pair.getSecondCard());                    a = a +1;                    hand.replace(card,a-1, a+1);                }            }        }        else {            hand.put(pair.getSecondCard(), 1);        }        for (PlayerObserver observer: observers){            observer.playerChanged(this);        }        //get all the possible routes that can be claimed        this.possibleRoutes = new ArrayList<>();        for(Route route: game.getRailroadMap().getRoutes()){            if(route.getBaron() == Baron.UNCLAIMED){                possibleRoutes.add(route);            }        }//commit now        //get the number of the most cards        int num = 0;        for(Map.Entry<Card, Integer> entry : hand.entrySet()){            if(entry.getValue() >= num){                num = entry.getValue();            }        }        //go through all the possible routes and find one that matches the greatest number        //cards that there are so that it is more likely to get the max num points possible        for(Route route: possibleRoutes){            if(route.getLength() == num && route.getLength()<= numTrainPieces){                try {                    //route.claim(this.baron);                    claimRoute(route);                } catch (RailroadBaronsException e) {                }                game.getRailroadMap().routeClaimed(route);                hasclaimed = true;                break;            }        }        //if there are no routes with the same length as the number of max cards, then go through        //the routes and find one that can be claimed.        if(!hasclaimed) {            for (Route route : possibleRoutes) {                if (route.getLength() <= num && route.getLength() <= numTrainPieces && this.canClaimRoute(route)) {                    //route.claim(this.baron);                    try {                        claimRoute(route);                    } catch (RailroadBaronsException e) {                        e.printStackTrace();                    }                    game.getRailroadMap().routeClaimed(route);                    hasclaimed = true;                    break;                }            }        }    }    /**     * Returns the most recently dealt {@linkplain Pair pair of cards}. Note     * that one or both of the {@linkplain Card cards} may have a value of     * {@link Card#NONE}.     *     * @return The most recently dealt {@link Pair} of {@link Card Cards}.     */    @Override    public Pair getLastTwoCards() {        return this.pair;    }    /**     * Returns the number of the specific kind of {@linkplain Card card} that     * the player currently has in hand. Note that the number may be 0.     *     * @param card The {@link Card} of interest.     * @return The number of the specified type of {@link Card} that the     * player currently has in hand.     */    @Override    public int countCardsInHand(Card card) {        int num =0;        for(Card c: hand.keySet()){            if(c.equals(card)){                num += hand.get(card);            }        }        return num;    }    /**     * Returns the number of game pieces that the player has remaining. Note     * that the number may be 0.     *     * @return The number of game pieces that the player has remaining.     */    @Override    public int getNumberOfPieces() {        return this.numTrainPieces;    }    /**     * Returns true iff the following conditions are true:     *     * <ul>     *     <li>The {@linkplain Route route} is not already claimed by this or     *     some other {@linkplain Baron baron}.</li>     *     <li>The player has not already claimed a route this turn (players     *     are limited to one claim per turn).</li>     *     <li>The player has enough {@linkplain Card cards} (including ONE     *     {@linkplain Card#WILD wild card, if necessary}) to claim the     *     route.</li>     *     <li>The player has enough train pieces to claim the route.</li>     * </ul>     *     * @param route The {@link Route} being tested to determine whether or not     *              the player is able to claim it.     * @return True if the player is able to claim the specified     * {@link Route}, and false otherwise.     */    @Override    public boolean canClaimRoute(Route route) {        int routeLength = route.getLength();        int wild  = 0;        int no =  0;        int greatestCardNum = 0;        if (hand.containsKey(Card.WILD)) {            wild = 1;            no = hand.get(Card.WILD);        }        hand.remove(Card.WILD);        for (Card card: hand.keySet()){            int cardNum = this.countCardsInHand(card);            if (cardNum > greatestCardNum){                greatestCardNum = cardNum;            }        }        hand.put(Card.WILD, no);        greatestCardNum += wild;        if(greatestCardNum >= routeLength && route.getBaron().equals(Baron.UNCLAIMED) && getNumberOfPieces() >= routeLength && !hasclaimed){            return true;        }        return false;    }    /**     * Claims the given {@linkplain Route route} on behalf of this player's     * {@linkplain Baron Railroad Baron}. It is possible that the player has     * enough cards in hand to claim the route by using different     * combinations of {@linkplain Card card}. It is up to the implementor to     * employ an algorithm that determines which cards to use, but here are     * some suggestions:     * <ul>     *     <li>Use the color with the lowest number of cards necessary to     *     match the length of the route.</li>     *     <li>Do not use a wild card unless absolutely necessary (i.e. the     *     player has length-1 cards of some color in hand and it is the most     *     numerous card that the player holds).</li>     * </ul>     *     * @param route The {@link Route} to claim.     *     * @throws RailroadBaronsException If the {@link Route} cannot be claimed,     * i.e. if the {@link #canClaimRoute(Route)} method returns false.     */    @Override    public void claimRoute(Route route) throws RailroadBaronsException {        if(this.canClaimRoute(route)){            hasclaimed = true;            claimedRoutes.add(route);            this.score += route.getPointValue();            this.numTrainPieces -= route.getLength();            route.claim(this.baron);            graph.addStation(route.getOrigin(), route.getDestination());            int i = this.score;            if (graph.findRoute(graph.getEndStation()).equals("westernmost") || graph.findRoute(graph.getEndStation()).equals("easternmost")){                i = i + (5 * this.game.getRailroadMap().getCols());            }            if (graph.findRoute(graph.getEndStation()).equals("northernmost") || graph.findRoute(graph.getEndStation()).equals("southernmost")){                i = i + (5 * this.game.getRailroadMap().getRows());            }            this.score = i;            int a = 0;            Card card0 = Card.WILD;            for (Card card: hand.keySet()){                if (hand.get(card) > a && card != Card.WILD){                    a = hand.get(card);                    card0 = card;                }            }            if (a >= route.getLength()) {                a = a - route.getLength();                hand.remove(card0);                hand.put(card0, a);            }            else if (a + 1 == route.getLength()){                if (hand.containsKey(Card.WILD)){                    int wild = hand.get(Card.WILD);                    wild = wild - 1;                    hand.remove(Card.WILD);                    hand.put(Card.WILD, wild);                    hand.remove(card0);                }            }            for(PlayerObserver po: observers){                po.playerChanged(this);            }        }        else{            throw new RailroadBaronsException("You attempted to claim a route that can't be claimed");        }    }    /**     * Returns the {@linkplain Collection collection} of {@linkplain Route     * routes} claimed by this player.     *     * @return The {@link Collection} of {@linkplain Route Routes} claimed by     * this player.     */    @Override    public Collection<Route> getClaimedRoutes() {        return this.claimedRoutes;    }    /**     * Returns the players current score based on the     * {@linkplain Route#getPointValue() point value} of each     * {@linkplain Route route} that the player has currently claimed.     *     * @return The player's current score.     */    @Override    public int getScore() {        return this.score;    }    /**     * Returns true iff the following conditions are true:     *     * <ul>     *     <li>The player has enough {@linkplain Card cards} (including     *     {@linkplain Card#WILD wild cards}) to claim a     *     {@linkplain Route route} of the specified length.</li>     *     <li>The player has enough train pieces to claim a     *     {@linkplain Route route} of the specified length.</li>     * </ul>     *     * @param shortestUnclaimedRoute The length of the shortest unclaimed     *                               {@link Route} in the current game.     *     * @return True if the player can claim such a {@link Route route}, and     * false otherwise.     */    @Override    public boolean canContinuePlaying(int shortestUnclaimedRoute) {        if(this.hand.isEmpty()){            return false;        }        int wild = 0;        int no = 0;        if (hand.containsKey(Card.WILD)){            wild = 1;            no = hand.get(Card.WILD);        }        hand.remove(Card.WILD);        for (Card card : hand.keySet()) {            if (numTrainPieces >= shortestUnclaimedRoute && countCardsInHand(card) + wild >= shortestUnclaimedRoute) {                return true;            }        }        hand.put(Card.WILD, no);        return false;    }    /*    toString to properly print out the player baron     */    public String toString(){        return this.baron.toString();    }}